% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Data Science R Basics},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\title{Data Science R Basics}
\author{}
\date{\vspace{-2.5em}}

\begin{document}
\maketitle

\hypertarget{learning-objectives}{%
\subsection{Learning Objectives}\label{learning-objectives}}

\begin{itemize}
\tightlist
\item
  Learn to read, extract, and create datasets in R
\item
  Learn to perform a variety of operations on datasets using R
\item
  Learn to write your own functions/sub-routines in R
\end{itemize}

\hypertarget{course-overview}{%
\subsection{Course Overview}\label{course-overview}}

\hypertarget{section-1-r-basics-functions-data-types}{%
\subsubsection{Section 1: R Basics, Functions, Data
types}\label{section-1-r-basics-functions-data-types}}

You will get started with R, learn about its functions and data types.

\hypertarget{section-2-vectors-sorting}{%
\subsubsection{Section 2: Vectors,
Sorting}\label{section-2-vectors-sorting}}

You will learn to operate on vectors and advanced functions such as
sorting.

\hypertarget{section-3-indexing-data-manipulation-plots}{%
\subsubsection{Section 3: Indexing, Data Manipulation,
Plots}\label{section-3-indexing-data-manipulation-plots}}

You will learn to wrangle and visualize data.

\hypertarget{section-4-programming-basics}{%
\subsubsection{Section 4: Programming
Basics}\label{section-4-programming-basics}}

You will learn to use general programming features like `if-else', and
`for loop' commands, and write your own functions to perform various
operations on datasets.

\hypertarget{section-1-overview}{%
\subsection{Section 1 Overview}\label{section-1-overview}}

Section 1 introduces you to R Basics, Functions and Datatypes.

In Section 1, you will learn to:

\begin{itemize}
\tightlist
\item
  Appreciate the rationale for data analysis using R
\item
  Define objects and perform basic arithmetic and logical operations
\item
  Use pre-defined functions to perform operations on objects
\item
  Distinguish between various data types
\end{itemize}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/r-basics.html}{here}

\hypertarget{motivation}{%
\subsection{Motivation}\label{motivation}}

Here is a link to the
\href{https://rafalab.github.io/dsbook/r-basics.html\#case-study-us-gun-murders}{textbook
section on the motivation for this course}.

\hypertarget{getting-started}{%
\subsection{Getting started}\label{getting-started}}

Here is a link to the textbook section on
\href{https://rafalab.github.io/dsbook/getting-started.html}{Getting
Started} with R.

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  R was developed by statisticians and data analysts as an interactive
  environment for data analysis.
\item
  Some of the advantages of R are that (1) it is free and open source,
  (2) it has the capability to save scripts, (3) there are numerous
  resources for learning, and (4) it is easy for developers to share
  software implementation.
\item
  Expressions are evaluated in the R console when you type the
  expression into the console and hit Return.
\item
  A great advantage of R over point and click analysis software is that
  you can save your work as scripts.
\item
  ``Base R'' is what you get after you first install R. Additional
  components are available via packages.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# installing the dslabs package}
\ControlFlowTok{if}\NormalTok{(}\OperatorTok{!}\KeywordTok{require}\NormalTok{(dslabs)) }\KeywordTok{install.packages}\NormalTok{(}\StringTok{"dslabs"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Loading required package: dslabs
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# loading the dslabs package into the R session}
\KeywordTok{library}\NormalTok{(dslabs)}
\end{Highlighting}
\end{Shaded}

\hypertarget{installing-r-and-r-studio}{%
\subsection{Installing R and R Studio}\label{installing-r-and-r-studio}}

\hypertarget{installing-r}{%
\subsubsection{Installing R}\label{installing-r}}

To install R to work on your own computer, you can download it freely
from the \href{https://cran.r-project.org}{Comprehensive R Archive
Network} (CRAN). Note that CRAN makes several versions of R available:
versions for multiple operating systems and releases older than the
current one. You want to read the CRAN instructions to assure you
download the correct version. If you need further help, you read the
walkthrough in this
\href{https://rafalab.github.io/dsbook/installing-r-rstudio.html\#installing-r}{Chapter
of the textbook}.

\hypertarget{installing-rstudio}{%
\subsubsection{Installing RStudio}\label{installing-rstudio}}

RStudio is an integrated development environment (IDE). We highly
recommend installing and using RStudio to edit and test your code. You
can install RStudio through the
\href{https://rstudio.com/products/rstudio/download/}{RStudio website}.
Their
\href{https://rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf}{cheatsheet}
is a great resource. You must install R before installing RStudio.

\hypertarget{textbook-link}{%
\subsubsection{Textbook Link}\label{textbook-link}}

Here is a link to the textbook section on
\href{https://rafalab.github.io/dsbook/installing-r-rstudio.html}{Installing
R and RStudio}.

\hypertarget{r-basics---objects}{%
\subsection{R Basics - Objects}\label{r-basics---objects}}

Here is a link to the textbook section on
\href{https://rafalab.github.io/dsbook/r-basics.html\#objects}{objects
in R}.

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  To define a variable, we may use the assignment symbol ``\textless-``.
\item
  There are two ways to see the value stored in a variable: (1) type the
  variable into the console and hit Return, or (2) type print(``variable
  name'') and hit Return.
\item
  Objects are stuff that is stored in R. They can be variables,
  functions, etc.
\item
  The ls() function shows the names of the objects saved in your
  workspace.
\end{itemize}

\emph{Solving the equation x2+x−1=0}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# assigning values to variables}
\NormalTok{a <-}\StringTok{ }\DecValTok{1}
\NormalTok{b <-}\StringTok{ }\DecValTok{1}
\NormalTok{c <-}\StringTok{ }\DecValTok{-1}

\CommentTok{# solving the quadratic equation}
\NormalTok{(}\OperatorTok{-}\NormalTok{b }\OperatorTok{+}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(b}\OperatorTok{^}\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{4}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{c) ) }\OperatorTok{/}\StringTok{ }\NormalTok{( }\DecValTok{2}\OperatorTok{*}\NormalTok{a )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.618034
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\OperatorTok{-}\NormalTok{b }\OperatorTok{-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(b}\OperatorTok{^}\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{4}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{c) ) }\OperatorTok{/}\StringTok{ }\NormalTok{( }\DecValTok{2}\OperatorTok{*}\NormalTok{a )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1.618034
\end{verbatim}

\hypertarget{r-basics---functions}{%
\subsection{R Basics - Functions}\label{r-basics---functions}}

Here is a link to the textbook section on
\href{https://rafalab.github.io/dsbook/r-basics.html\#functions}{functions}.

\textbf{Key points}

\begin{itemize}
\tightlist
\item
  In general, to evaluate a function we need to use parentheses. If we
  type a function without parenthesis, R shows us the code for the
  function. Most functions also require an argument, that is, something
  to be written inside the parenthesis.
\item
  To access help files, we may use the help function help(``function
  name''), or write the question mark followed by the function name.
\item
  The help file shows you the arguments the function is expecting, some
  of which are required and some are optional. If an argument is
  optional, a default value is assigned with the equal sign. The args()
  function also shows the arguments a function needs.
\item
  To specify arguments, we use the equals sign. If no argument name is
  used, R assumes you're entering arguments in the order shown in the
  help file.
\item
  Creating and saving a script makes code much easier to execute.
\item
  To make your code more readable, use intuitive variable names and
  include comments (using the ``\#'' symbol) to remind yourself why you
  wrote a particular line of code.
\end{itemize}

\hypertarget{assessment---r-basics}{%
\subsection{Assessment - R Basics}\label{assessment---r-basics}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  What is the sum of the first n positive integers? We can use the
  formula \(n(n+1)/2\) to quickly compute this quantity.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Here is how you compute the sum for the first 20 integers}
\DecValTok{20}\OperatorTok{*}\NormalTok{(}\DecValTok{20}\OperatorTok{+}\DecValTok{1}\NormalTok{)}\OperatorTok{/}\DecValTok{2} 
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 210
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# However, we can define a variable to use the formula for other values of n}
\NormalTok{n <-}\StringTok{ }\DecValTok{20}
\NormalTok{n}\OperatorTok{*}\NormalTok{(n}\OperatorTok{+}\DecValTok{1}\NormalTok{)}\OperatorTok{/}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 210
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{25}
\NormalTok{n}\OperatorTok{*}\NormalTok{(n}\OperatorTok{+}\DecValTok{1}\NormalTok{)}\OperatorTok{/}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 325
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Below, write code to calculate the sum of the first 100 integers}
\NormalTok{n<-}\DecValTok{100}
\NormalTok{n}\OperatorTok{*}\NormalTok{(n}\OperatorTok{+}\DecValTok{1}\NormalTok{)}\OperatorTok{/}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5050
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  What is the sum of the first 1000 positive integers? We can use the
  formula \(n(n+1)/2\) to quickly compute this quantity.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Below, write code to calculate the sum of the first 1000 integers }
\NormalTok{n<-}\DecValTok{1000}
\NormalTok{n}\OperatorTok{*}\NormalTok{(n}\OperatorTok{+}\DecValTok{1}\NormalTok{)}\OperatorTok{/}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 500500
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Run the following code in the R console.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1000}
\NormalTok{x <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, n)}
\KeywordTok{sum}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 500500
\end{verbatim}

Based on the result, what do you think the functions \texttt{seq} and
\texttt{sum} do?

\begin{itemize}
\tightlist
\item[$\square$]
  A. sum creates a list of numbers and seq adds them up.
\item[$\boxtimes$]
  B. seq creates a list of numbers and sum adds them up.
\item[$\square$]
  C. seq computes the difference between two arguments and sum computes
  the sum of 1 through 1000.
\item[$\square$]
  D. sum always returns the same number.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  In math and programming we say we evaluate a function when we replace
  arguments with specific values. So if we type \texttt{log2(16)} we
  evaluate the \texttt{log2} function to get the log base 2 of
  \texttt{16} which is \texttt{4}.
\end{enumerate}

In R it is often useful to evaluate a function inside another function.
For example, \texttt{sqrt(log2(16))} will calculate the log to the base
2 of 16 and then compute the square root of that value. So the first
evaluation gives a 4 and this gets evaluated by \texttt{sqrt} to give
the final answer of 2.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# log to the base 2 }
\KeywordTok{log2}\NormalTok{(}\DecValTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# sqrt of the log to the base 2 of 16:}
\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{log2}\NormalTok{(}\DecValTok{16}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Compute log to the base 10 (log10) of the sqrt of 100. Do not use variables.}
\KeywordTok{log10}\NormalTok{(}\KeywordTok{sqrt}\NormalTok{(}\DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Which of the following will always return the numeric value stored in
  \texttt{x}? You can try out examples and use the help system in the R
  console.
\end{enumerate}

\begin{itemize}
\tightlist
\item[$\square$]
  A. log(10\^{}x)
\item[$\square$]
  B. log10(x\^{}10)
\item[$\boxtimes$]
  C. log(exp(x))
\item[$\square$]
  D. exp(log(x, base = 2))
\end{itemize}

\hypertarget{data-types}{%
\subsection{Data Types}\label{data-types}}

You can find the
\href{https://rafalab.github.io/dsbook/r-basics.html\#data-types}{section
of the textbook on data types here}.

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  The function ``class'' helps us determine the type of an object.
\item
  Data frames can be thought of as tables with rows representing
  observations and columns representing different variables.
\item
  To access data from columns of a data frame, we use the dollar sign
  symbol, which is called the accessor.
\item
  A vector is an object consisting of several entries and can be a
  numeric vector, a character vector, or a logical vector.
\item
  We use quotes to distinguish between variable names and character
  strings.
\item
  Factors are useful for storing categorical data, and are more memory
  efficient than storing characters.
\end{itemize}

\emph{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# loading the the murders dataset}
\KeywordTok{data}\NormalTok{(murders)}

\CommentTok{# determining that the murders dataset is of the "data frame" class}
\KeywordTok{class}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "data.frame"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# finding out more about the structure of the object}
\KeywordTok{str}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    51 obs. of  5 variables:
##  $ state     : chr  "Alabama" "Alaska" "Arizona" "Arkansas" ...
##  $ abb       : chr  "AL" "AK" "AZ" "AR" ...
##  $ region    : Factor w/ 4 levels "Northeast","South",..: 2 4 4 2 4 4 1 2 2 2 ...
##  $ population: num  4779736 710231 6392017 2915918 37253956 ...
##  $ total     : num  135 19 232 93 1257 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# showing the first 6 lines of the dataset}
\KeywordTok{head}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        state abb region population total
## 1    Alabama  AL  South    4779736   135
## 2     Alaska  AK   West     710231    19
## 3    Arizona  AZ   West    6392017   232
## 4   Arkansas  AR  South    2915918    93
## 5 California  CA   West   37253956  1257
## 6   Colorado  CO   West    5029196    65
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# using the accessor operator to obtain the population column}
\NormalTok{murders}\OperatorTok{$}\NormalTok{population}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  4779736   710231  6392017  2915918 37253956  5029196  3574097   897934
##  [9]   601723 19687653  9920000  1360301  1567582 12830632  6483802  3046355
## [17]  2853118  4339367  4533372  1328361  5773552  6547629  9883640  5303925
## [25]  2967297  5988927   989415  1826341  2700551  1316470  8791894  2059179
## [33] 19378102  9535483   672591 11536504  3751351  3831074 12702379  1052567
## [41]  4625364   814180  6346105 25145561  2763885   625741  8001024  6724540
## [49]  1852994  5686986   563626
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# displaying the variable names in the murders dataset}
\KeywordTok{names}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "state"      "abb"        "region"     "population" "total"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# determining how many entries are in a vector}
\NormalTok{pop <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population}
\KeywordTok{length}\NormalTok{(pop)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 51
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# vectors can be of class numeric and character}
\KeywordTok{class}\NormalTok{(pop)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(murders}\OperatorTok{$}\NormalTok{state)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# logical vectors are either TRUE or FALSE}
\NormalTok{z <-}\StringTok{ }\DecValTok{3} \OperatorTok{==}\StringTok{ }\DecValTok{2}
\NormalTok{z}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(z)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "logical"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# factors are another type of class}
\KeywordTok{class}\NormalTok{(murders}\OperatorTok{$}\NormalTok{region)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "factor"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# obtaining the levels of a factor}
\KeywordTok{levels}\NormalTok{(murders}\OperatorTok{$}\NormalTok{region)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Northeast"     "South"         "North Central" "West"
\end{verbatim}

\hypertarget{assessment---data-types}{%
\subsection{Assessment - Data Types}\label{assessment---data-types}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  We're going to be using the following dataset for this module. Run
  this code in the console.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dslabs)  }
\KeywordTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

Next, use the function \texttt{str} to examine the structure of the
\texttt{murders} object. We can see that this object is a data frame
with 51 rows and five columns.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    51 obs. of  5 variables:
##  $ state     : chr  "Alabama" "Alaska" "Arizona" "Arkansas" ...
##  $ abb       : chr  "AL" "AK" "AZ" "AR" ...
##  $ region    : Factor w/ 4 levels "Northeast","South",..: 2 4 4 2 4 4 1 2 2 2 ...
##  $ population: num  4779736 710231 6392017 2915918 37253956 ...
##  $ total     : num  135 19 232 93 1257 ...
\end{verbatim}

Which of the following best describes the variables represented in this
data frame?

\begin{itemize}
\tightlist
\item[$\square$]
  A. The 51 states.
\item[$\square$]
  B. The murder rates for all 50 states and DC.
\item[$\boxtimes$]
  C. The state name, the abbreviation of the state name, the state's
  region, and the state's population and total number of murders for
  2010.
\item[$\square$]
  D. str shows no relevant information.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  In the previous question, we saw the different variables that are a
  part of this dataset from the output of the \texttt{str()} function.
  The function \texttt{names()} is specifically designed to extract the
  column names from a data frame.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Load package and data}
\KeywordTok{library}\NormalTok{(dslabs)}
\KeywordTok{data}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use the function names to extract the variable names }
\KeywordTok{names}\NormalTok{(murders)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "state"      "abb"        "region"     "population" "total"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  In this module we have learned that every variable has a class. For
  example, the class can be a \emph{character}, \emph{numeric} or
  \emph{logical}. The function \texttt{class()} can be used to determine
  the class of an object.
\end{enumerate}

Here we are going to determine the class of one of the variables in the
\texttt{murders} data frame. To extract variables from a data frame we
use \texttt{\$}, referred to as the accessor.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# To access the population variable from the murders dataset use this code:}
\NormalTok{p <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population }

\CommentTok{# To determine the class of object `p` we use this code:}
\KeywordTok{class}\NormalTok{(p)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use the accessor to extract state abbreviations and assign it to a}
\NormalTok{a <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{abb}

\CommentTok{# Determine the class of a}
\KeywordTok{class}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  An important lesson you should learn early on is that there are
  multiple ways to do things in R. For example, to generate the first
  five integers we note that \texttt{1:5} and \texttt{seq(1,5)} return
  the same result.
\end{enumerate}

There are also multiple ways to access variables in a data frame. For
example we can use the square brackets \texttt{{[}{[}} instead of the
accessor \texttt{\$}.

If you instead try to access a column with just one bracket,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murders[}\StringTok{"population"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

R returns a subset of the original data frame containing just this
column. This new object will be of class \texttt{data.frame} rather than
a vector. To access the column itself you need to use either the
\texttt{\$} accessor or the double square brackets \texttt{{[}{[}}.

Parentheses, in contrast, are mainly used alongside functions to
indicate what argument the function should be doing something to. For
example, when we did \texttt{class(p)} in the last question, we wanted
the function \texttt{class} to do something related to the argument
\texttt{p}.

This is an example of how R can be a bit idiosyncratic sometimes. It is
very common to find it confusing at first.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# We extract the population like this:}
\NormalTok{p <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population}

\CommentTok{# This is how we do the same with the square brackets:}
\NormalTok{o <-}\StringTok{ }\NormalTok{murders[[}\StringTok{"population"}\NormalTok{]]}

\CommentTok{# We can confirm these two are the same}
\KeywordTok{identical}\NormalTok{(o, p)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use square brackets to extract `abb` from `murders` and assign it to b}
\NormalTok{b <-}\StringTok{ }\NormalTok{murders[[}\StringTok{"abb"}\NormalTok{]]}

\CommentTok{# Check if `a` and `b` are identical }
\KeywordTok{identical}\NormalTok{(a, b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Using the \texttt{str()} command, we saw that the \emph{region} column
  stores a factor. You can corroborate this by using the \texttt{class}
  command on the \emph{region} column.
\end{enumerate}

The function \texttt{levels} shows us the categories for the factor.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# We can see the class of the region variable using class}
\KeywordTok{class}\NormalTok{(murders}\OperatorTok{$}\NormalTok{region)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "factor"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Determine the number of regions included in this variable }
\KeywordTok{length}\NormalTok{(}\KeywordTok{levels}\NormalTok{(murders}\OperatorTok{$}\NormalTok{region))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  The function \texttt{table} takes a vector as input and returns the
  frequency of each unique element in the vector.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Here is an example of what the table function does}
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{)}
\KeywordTok{table}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## x
## a b c 
## 2 3 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Write one line of code to show the number of states per region}
\KeywordTok{table}\NormalTok{(murders}\OperatorTok{$}\NormalTok{region)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##     Northeast         South North Central          West 
##             9            17            12            13
\end{verbatim}

\hypertarget{section-1-assessment}{%
\subsection{Section 1 Assessment}\label{section-1-assessment}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  To find the solutions to an equation of the format \(ax^2+bx+c\), use
  the quadratic equation: \(x=\frac{-b±\sqrt(b^2−4ac)}{2a}\).
\end{enumerate}

What are the two solutions to \(2x^2-x-4=0\)? Use the quadratic
equation. (Report the greater of the two solutions first, using 3
significant digits for both solutions)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{options}\NormalTok{(}\DataTypeTok{digits =} \DecValTok{3}\NormalTok{)}
\NormalTok{a <-}\StringTok{ }\DecValTok{2}
\NormalTok{b <-}\StringTok{ }\DecValTok{-1}
\NormalTok{c <-}\StringTok{ }\DecValTok{-4}
\NormalTok{(}\OperatorTok{-}\NormalTok{b}\OperatorTok{+}\KeywordTok{sqrt}\NormalTok{(b}\OperatorTok{^}\DecValTok{2-4}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{c))}\OperatorTok{/}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.69
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\OperatorTok{-}\NormalTok{b}\OperatorTok{-}\KeywordTok{sqrt}\NormalTok{(b}\OperatorTok{^}\DecValTok{2-4}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{c))}\OperatorTok{/}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\NormalTok{a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1.19
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Use R to compute log base 4 of 1024. You can use the \texttt{help}
  function to learn how to use arguments to change the base of the
  \texttt{log} function.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{1024}\NormalTok{, }\DataTypeTok{base =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Load the \texttt{movielens} dataset
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(movielens)}
\KeywordTok{str}\NormalTok{(movielens)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    100004 obs. of  7 variables:
##  $ movieId  : int  31 1029 1061 1129 1172 1263 1287 1293 1339 1343 ...
##  $ title    : chr  "Dangerous Minds" "Dumbo" "Sleepers" "Escape from New York" ...
##  $ year     : int  1995 1941 1996 1981 1989 1978 1959 1982 1992 1991 ...
##  $ genres   : Factor w/ 901 levels "(no genres listed)",..: 762 510 899 120 762 836 81 762 844 899 ...
##  $ userId   : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ rating   : num  2.5 3 3 2 4 2 2 2 3.5 2 ...
##  $ timestamp: int  1260759144 1260759179 1260759182 1260759185 1260759205 1260759151 1260759187 1260759148 1260759125 1260759131 ...
\end{verbatim}

How many rows are in the dataset? \texttt{100004}

How many different variables are in the dataset? \texttt{7}

What is the variable type of \texttt{title}?

\begin{itemize}
\tightlist
\item[$\square$]
  A. It is a text (txt) variable
\item[$\square$]
  B. It is a chronological (chr) variable
\item[$\square$]
  C. It is a string (str) variable
\item[$\square$]
  D. It is a numeric (num) variable
\item[$\square$]
  E. It is an integer (int) variable
\item[$\square$]
  F. It is a factor (Factor) variable
\item[$\boxtimes$]
  G. It is a character (chr) variable
\end{itemize}

What is the variable type of \texttt{genres}?

\begin{itemize}
\tightlist
\item[$\square$]
  A. It is a text (txt) variable
\item[$\square$]
  B. It is a chronological (chr) variable
\item[$\square$]
  C. It is a string (str) variable
\item[$\square$]
  D. It is a numeric (num) variable
\item[$\square$]
  E. It is an integer (int) variable
\item[$\boxtimes$]
  F. It is a factor (Factor) variable
\item[$\square$]
  G. It is a character (chr) variable
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  We already know we can use the \texttt{levels()} function to determine
  the levels of a factor. A different function, \texttt{nlevels()}, may
  be used to determine the number of levels of a factor.
\end{enumerate}

Use this function to determine how many levels are in the factor
\texttt{genres} in the \texttt{movielens} data frame.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nlevels}\NormalTok{(movielens}\OperatorTok{$}\NormalTok{genres)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 901
\end{verbatim}

\hypertarget{section-2-overview}{%
\subsection{Section 2 Overview}\label{section-2-overview}}

In Section 2.1, you will:

\begin{itemize}
\tightlist
\item
  Create numeric and character vectors.
\item
  Name the columns of a vector.
\item
  Generate numeric sequences.
\item
  Access specific elements or parts of a vector.
\item
  Coerce data into different data types as needed.
\end{itemize}

In Section 2.2, you will:

\begin{itemize}
\tightlist
\item
  Sort vectors in ascending and descending order.
\item
  Extract the indices of the sorted elements from the original vector.
\item
  Find the maximum and minimum elements, as well as their indices, in a
  vector.
\item
  Rank the elements of a vector in increasing order.
\end{itemize}

In Section 2.3, you will:

\begin{itemize}
\tightlist
\item
  Perform arithmetic between a vector and a single number.
\item
  Perform arithmetic between two vectors of same length.
\end{itemize}

\hypertarget{vectors}{%
\subsection{Vectors}\label{vectors}}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/r-basics.html\#vectors}{here}

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  The function \texttt{c()}, which stands for concatenate, is useful for
  creating vectors.
\item
  Another useful function for creating vectors is the \texttt{seq()}
  function, which generates sequences.
\item
  Subsetting lets us access specific parts of a vector by using square
  brackets to access elements of a vector.
\end{itemize}

\emph{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# We may create vectors of class numeric or character with the concatenate function}
\NormalTok{codes <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{380}\NormalTok{, }\DecValTok{124}\NormalTok{, }\DecValTok{818}\NormalTok{)}
\NormalTok{country <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"italy"}\NormalTok{, }\StringTok{"canada"}\NormalTok{, }\StringTok{"egypt"}\NormalTok{)}

\CommentTok{# We can also name the elements of a numeric vector}
\CommentTok{# Note that the two lines of code below have the same result}
\NormalTok{codes <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{italy =} \DecValTok{380}\NormalTok{, }\DataTypeTok{canada =} \DecValTok{124}\NormalTok{, }\DataTypeTok{egypt =} \DecValTok{818}\NormalTok{)}
\NormalTok{codes <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"italy"}\NormalTok{ =}\StringTok{ }\DecValTok{380}\NormalTok{, }\StringTok{"canada"}\NormalTok{ =}\StringTok{ }\DecValTok{124}\NormalTok{, }\StringTok{"egypt"}\NormalTok{ =}\StringTok{ }\DecValTok{818}\NormalTok{)}

\CommentTok{# We can also name the elements of a numeric vector using the names() function}
\NormalTok{codes <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{380}\NormalTok{, }\DecValTok{124}\NormalTok{, }\DecValTok{818}\NormalTok{)}
\NormalTok{country <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"italy"}\NormalTok{,}\StringTok{"canada"}\NormalTok{,}\StringTok{"egypt"}\NormalTok{)}
\KeywordTok{names}\NormalTok{(codes) <-}\StringTok{ }\NormalTok{country}

\CommentTok{# Using square brackets is useful for subsetting to access specific elements of a vector}
\NormalTok{codes[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## canada 
##    124
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## italy egypt 
##   380   818
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  italy canada 
##    380    124
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# If the entries of a vector are named, they may be accessed by referring to their name}
\NormalTok{codes[}\StringTok{"canada"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## canada 
##    124
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codes[}\KeywordTok{c}\NormalTok{(}\StringTok{"egypt"}\NormalTok{,}\StringTok{"italy"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## egypt italy 
##   818   380
\end{verbatim}

\hypertarget{vectors---vector-coercion}{%
\subsection{Vectors - Vector Coercion}\label{vectors---vector-coercion}}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/r-basics.html\#coercion}{here}

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  In general, \emph{coercion} is an attempt by R to be flexible with
  data types by guessing what was meant when an entry does not match the
  expected. For example, when defining x as
\end{itemize}

x \textless- c(1, ``canada'', 3)

R \emph{coerced} the data into characters. It guessed that because you
put a character string in the vector, you meant the 1 and 3 to actually
be character strings ``1'' and ``3''.

\begin{itemize}
\tightlist
\item
  The function \texttt{as.character()} turns numbers into characters.
\item
  The function \texttt{as.numeric()} turns characters into numbers.
\item
  In R, missing data is assigned the value NA.
\end{itemize}

\hypertarget{assessment---vectors}{%
\subsection{Assessment - Vectors}\label{assessment---vectors}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A vector is a series of values, all of the same type. They are the
  most basic data type in R and can hold numeric data, character data,
  or logical data. In R, you can create a vector with the concatenate
  (or combine) function \texttt{c()}
\end{enumerate}

You place the vector elements separated by a comma between the
parentheses. For example a numeric vector would look something like
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cost <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{50}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Here is an example creating a numeric vector named cost}
\NormalTok{cost <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{50}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{)}

\CommentTok{# Create a numeric vector to store the temperatures listed in the instructions into a vector named temp}
\CommentTok{# Make sure to follow the same order in the instructions}
\NormalTok{temp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{=}\DecValTok{35}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{=}\DecValTok{88}\NormalTok{, }\StringTok{"Paris"}\NormalTok{=}\DecValTok{42}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{=}\DecValTok{84}\NormalTok{, }\StringTok{"San Juan"}\NormalTok{=}\DecValTok{81}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{=}\DecValTok{30}\NormalTok{)}
\NormalTok{cost}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  50  75  90 100 150
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        Beijing          Lagos          Paris Rio de Janeiro       San Juan 
##             35             88             42             84             81 
##        Toronto 
##             30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(temp)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  As in the previous question, we are going to create a vector. Only
  this time, we learn to create \emph{character} vectors. The main
  difference is that these have to be written as strings and so the
  names are enclosed within double quotes.
\end{enumerate}

A \emph{character} vector would look something like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{food <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"pizza"}\NormalTok{, }\StringTok{"burgers"}\NormalTok{, }\StringTok{"salads"}\NormalTok{, }\StringTok{"cheese"}\NormalTok{, }\StringTok{"pasta"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# here is an example of how to create a character vector}
\NormalTok{food <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"pizza"}\NormalTok{, }\StringTok{"burgers"}\NormalTok{, }\StringTok{"salads"}\NormalTok{, }\StringTok{"cheese"}\NormalTok{, }\StringTok{"pasta"}\NormalTok{)}

\CommentTok{# Create a character vector called city to store the city names}
\CommentTok{# Make sure to follow the same order as in the instructions}
\NormalTok{city <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  We have successfully assigned the temperatures as \emph{numeric}
  values to \texttt{temp} and the \texttt{city} names as character
  values to city. But can we associate the temperature to its related
  city? Yes! We can do so using a code we already know - \texttt{names}.
  We assign names to the \emph{numeric} values.
\end{enumerate}

It would look like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cost <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{50}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{)}
\NormalTok{food <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"pizza"}\NormalTok{, }\StringTok{"burgers"}\NormalTok{, }\StringTok{"salads"}\NormalTok{, }\StringTok{"cheese"}\NormalTok{, }\StringTok{"pasta"}\NormalTok{)}
\KeywordTok{names}\NormalTok{(cost) <-}\StringTok{ }\NormalTok{food}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Associate the cost values with its corresponding food item}
\NormalTok{cost <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{50}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{150}\NormalTok{)}
\NormalTok{food <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"pizza"}\NormalTok{, }\StringTok{"burgers"}\NormalTok{, }\StringTok{"salads"}\NormalTok{, }\StringTok{"cheese"}\NormalTok{, }\StringTok{"pasta"}\NormalTok{)}
\KeywordTok{names}\NormalTok{(cost) <-}\StringTok{ }\NormalTok{food}

\CommentTok{# You already wrote this code}
\NormalTok{temp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{84}\NormalTok{, }\DecValTok{81}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\NormalTok{city <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}

\CommentTok{# Associate the temperature values with its corresponding city}
\KeywordTok{names}\NormalTok{(temp) <-}\StringTok{ }\NormalTok{city}
\NormalTok{temp}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        Beijing          Lagos          Paris Rio de Janeiro       San Juan 
##             35             88             42             84             81 
##        Toronto 
##             30
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  If we want to display only selected values from the object, R can help
  us do that easily.
\end{enumerate}

For example, if we want to see the cost of the last 3 items in our food
list, we would type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cost[}\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Note here, that we could also type \texttt{cost{[}c(3,4,5){]}} and get
the same result. The \texttt{:} operator helps us condense the code and
get consecutive values.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# cost of the last 3 items in our food list:}
\NormalTok{cost[}\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## salads cheese  pasta 
##     90    100    150
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# temperatures of the first three cities in the list:}
\NormalTok{temp[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Beijing   Lagos   Paris 
##      35      88      42
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  In the previous question, we accessed the temperature for consecutive
  cities (1st three). But what if we want to access the temperatures for
  any 2 specific cities?
\end{enumerate}

An example: To access the cost of \texttt{pizza} (1st) and
\texttt{pasta} (5th food item) in our list, the code would be:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cost[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Access the cost of pizza and pasta from our food list }
\NormalTok{cost[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## pizza pasta 
##    50   150
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Define temp}
\NormalTok{temp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{84}\NormalTok{, }\DecValTok{81}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\NormalTok{city <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}
\KeywordTok{names}\NormalTok{(temp) <-}\StringTok{ }\NormalTok{city}

\CommentTok{# Access the temperatures of Paris and San Juan}
\NormalTok{temp[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Paris San Juan 
##       42       81
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  The \texttt{:} operator helps us create sequences of numbers. For
  example, \texttt{32:99} would create a list of numbers from 32 to 99.
\end{enumerate}

Then, if we want to know the length of this sequence, all we need to do
is use the \texttt{length} command.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a vector m of integers that starts at 32 and ends at 99.}
\NormalTok{m <-}\StringTok{ }\DecValTok{32}\OperatorTok{:}\DecValTok{99}

\CommentTok{# Determine the length of object m.}
\KeywordTok{length}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 68
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a vector x of integers that starts at 12 and ends at 73.}
\NormalTok{x <-}\StringTok{ }\DecValTok{12}\OperatorTok{:}\DecValTok{73}

\CommentTok{# Determine the length of object x.}
\KeywordTok{length}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 62
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  We can also create different types of sequences in R. For example, in
  \texttt{seq(7,\ 49,\ 7)}, the first argument defines the start, and
  the second the end. The default is to go up in increments of 1, but a
  third argument lets us tell it by what interval.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a vector with the multiples of 7, smaller than 50.}
\KeywordTok{seq}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{49}\NormalTok{, }\DecValTok{7}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  7 14 21 28 35 42 49
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a vector containing all the positive odd numbers smaller than 100.}
\CommentTok{# The numbers should be in ascending order}
\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{99}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49
## [26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  The second argument of the function \texttt{seq} is actually a
  maximum, not necessarily the end.
\end{enumerate}

So if we type

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

we actually get the same vector of integers as if we type

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{49}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This can be useful because sometimes all we want are sequential numbers
that are smaller than some value. Let's look at an example.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# We can create a vector with the multiples of 7, smaller than 50 like this }
\KeywordTok{seq}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{49}\NormalTok{, }\DecValTok{7}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  7 14 21 28 35 42 49
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# But note that the second argument does not need to be the last number}
\CommentTok{# It simply determines the maximum value permitted}
\CommentTok{# so the following line of code produces the same vector as seq(7, 49, 7)}
\KeywordTok{seq}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  7 14 21 28 35 42 49
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a sequence of numbers from 6 to 55, with 4/7 increments and determine its length}
\KeywordTok{length}\NormalTok{(}\KeywordTok{seq}\NormalTok{(}\DecValTok{6}\NormalTok{,}\DecValTok{55}\NormalTok{,}\DecValTok{4}\OperatorTok{/}\DecValTok{7}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 86
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\tightlist
\item
  The \texttt{seq()} function has another useful argument. The argument
  \emph{length.out}. This argument lets us generate sequences that are
  increasing by the same amount but are of the prespecified length.
\end{enumerate}

For example, this line of code

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{5}\NormalTok{)}
\NormalTok{produces the numbers }\DecValTok{0}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{75}\NormalTok{, }\FloatTok{100.}
\end{Highlighting}
\end{Shaded}

Let's create a vector and see what is the class of the object produced.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the sequence in the object a}
\NormalTok{a <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{100}\NormalTok{)}

\CommentTok{# Determine the class of a}
\KeywordTok{class}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{9}
\tightlist
\item
  We have discussed the numeric class. We just saw that the \texttt{seq}
  function can generate objects of this class.
\end{enumerate}

For another example, type

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\FloatTok{0.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

into the console and note that the \texttt{class} is \emph{numeric}. R
has another type of vector we have not described, the \emph{integer}
class. You can create an \emph{integer} by adding the letter \texttt{L}
after a whole number. If you type

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(3L)}
\end{Highlighting}
\end{Shaded}

in the console, you see this is an \emph{integer} and not a
\emph{numeric}. For most practical purposes, integers and numerics are
indistinguishable. For example 3, the integer, minus 3 the numeric is 0.
To see this type this in the console

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{3L }\OperatorTok{-}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

The main difference is that integers occupy less space in the computer
memory, so for big computations using integers can have a substantial
impact.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the sequence in the object a}
\NormalTok{a <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{10}\NormalTok{)}

\CommentTok{# Determine the class of a}
\KeywordTok{class}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{10}
\tightlist
\item
  Let's confirm that \texttt{1L} is an \emph{integer} not a
  \emph{numeric}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Check the class of 1, assigned to the object a}
\KeywordTok{class}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Confirm the class of 1L is integer}
\KeywordTok{class}\NormalTok{(1L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{11}
\tightlist
\item
  The concept of coercion is a very important one. Watching the video,
  we learned that when an entry does not match what an R function is
  expecting, R tries to guess what we meant before throwing an error.
  This might get confusing at times.
\end{enumerate}

As we've discussed in earlier questions, there are numeric and character
vectors. The character vectors are placed in quotes and the numerics are
not.

We can avoid issues with coercion in R by changing characters to
numerics and vice-versa. This is known as typecasting. The code,
\texttt{as.numeric(x)} helps us convert character strings to numbers.
There is an equivalent function that converts its argument to a string,
\texttt{as.character(x)}.

Let's practice doing this!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Define the vector x}
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{,}\StringTok{"a"}\NormalTok{)}

\CommentTok{# Note that the x is character vector}
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1" "3" "5" "a"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Typecast the vector to get an integer vector}
\CommentTok{# You will get a warning but that is ok}
\NormalTok{x <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs introduced by coercion
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  3  5 NA
\end{verbatim}

\hypertarget{sorting}{%
\subsection{Sorting}\label{sorting}}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/r-basics.html\#sorting}{here}

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  The function \texttt{sort()} sorts a vector in increasing order.
\item
  The function \texttt{order()} produces the indices needed to obtain
  the sorted vector, e.g.~a result of 2 3 1 5 4 means the sorted vector
  will be produced by listing the 2nd, 3rd, 1st, 5th, and then 4th item
  of the original vector.
\item
  The function \texttt{rank()} gives us the ranks of the items in the
  original vector.
\item
  The function \texttt{max()} returns the largest value while
  \texttt{which.max()} returns the index of the largest value. The
  functions \texttt{min()} and \texttt{which.min()} work similarly for
  minimum values.
\end{itemize}

\hypertarget{assessment---sorting}{%
\subsection{Assessment - Sorting}\label{assessment---sorting}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  When looking at a dataset, we may want to sort the data in an order
  that makes more sense for analysis. Let's learn to do this using the
  \texttt{murders} dataset as an example
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Access the `state` variable and store it in an object }
\NormalTok{states <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{state }

\CommentTok{# Sort the object alphabetically and redefine the object }
\NormalTok{states <-}\StringTok{ }\KeywordTok{sort}\NormalTok{(states) }

\CommentTok{# Report the first alphabetical value  }
\NormalTok{states[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Alabama"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Access population values from the dataset and store it in pop}
\NormalTok{pop <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population}

\CommentTok{# Sort the object and save it in the same object}
\NormalTok{pop <-}\StringTok{ }\KeywordTok{sort}\NormalTok{(pop)}

\CommentTok{# Report the smallest population size }
\NormalTok{pop[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 563626
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  The function \texttt{order()} returns the index vector needed to sort
  the vector. This implies that \texttt{sort(x)} and
  \texttt{x{[}order(x){]}} give the same result.
\end{enumerate}

This can be useful for finding row numbers with certain properties such
as ``the row for the state with the smallest population''. Remember that
when we extract a variable from a data frame the order of the resulting
vector is the same as the order of the rows of the data frame. So for
example, the entries of the vector \texttt{murders\$state} are ordered
in the same way as the states if you go down the rows of
\texttt{murders}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Access population from the dataset and store it in pop}
\NormalTok{pop <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population}

\CommentTok{# Use the command order to find the vector of indexes that order pop and store in object ord}
\NormalTok{ord <-}\StringTok{ }\KeywordTok{order}\NormalTok{(pop)}

\CommentTok{# Find the index number of the entry with the smallest population size}
\NormalTok{ord[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 51
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  We can actually perform the same operation as in the previous exercise
  using the function \texttt{which.min}. It basically tells us which is
  the minimum value.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Find the index of the smallest value for variable total }
\KeywordTok{which.min}\NormalTok{(murders}\OperatorTok{$}\NormalTok{total)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 46
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Find the index of the smallest value for population}
\KeywordTok{which.min}\NormalTok{(murders}\OperatorTok{$}\NormalTok{population)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 51
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Now we know how small the smallest state is and we know which row
  represents it. However, which state is it?
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Define the variable i to be the index of the smallest state}
\NormalTok{i <-}\StringTok{ }\KeywordTok{which.min}\NormalTok{(murders}\OperatorTok{$}\NormalTok{population)}

\CommentTok{# Define variable states to hold the states}
\NormalTok{states <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{state}

\CommentTok{# Use the index you just defined to find the state with the smallest population}
\NormalTok{states[i]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Wyoming"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  You can create a data frame using the data.frame function.
\end{enumerate}

Here is a quick example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{84}\NormalTok{, }\DecValTok{81}\NormalTok{, }\DecValTok{30}\NormalTok{)}
\NormalTok{city <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}
\NormalTok{city_temps <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{name =}\NormalTok{ city, }\DataTypeTok{temperature =}\NormalTok{ temp)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store temperatures in an object }
\NormalTok{temp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{84}\NormalTok{, }\DecValTok{81}\NormalTok{, }\DecValTok{30}\NormalTok{)}

\CommentTok{# Store city names in an object }
\NormalTok{city <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}

\CommentTok{# Create data frame with city names and temperature }
\NormalTok{city_temps <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{name =}\NormalTok{ city, }\DataTypeTok{temperature =}\NormalTok{ temp)}

\CommentTok{# Define a variable states to be the state names }
\NormalTok{states <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{state}

\CommentTok{# Define a variable ranks to determine the population size ranks }
\NormalTok{ranks <-}\StringTok{ }\KeywordTok{rank}\NormalTok{(murders}\OperatorTok{$}\NormalTok{population)}

\CommentTok{# Create a data frame my_df with the state name and its rank}
\NormalTok{my_df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{name =}\NormalTok{ states, }\DataTypeTok{rank =}\NormalTok{ ranks)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  This exercise is somewhat more challenging. We are going to repeat the
  previous exercise but this time order `\texttt{my\_df} so that the
  states are ordered from least populous to most.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Define a variable states to be the state names from the murders data frame}
\NormalTok{states <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{state}

\CommentTok{# Define a variable ranks to determine the population size ranks }
\NormalTok{ranks <-}\StringTok{ }\KeywordTok{rank}\NormalTok{(murders}\OperatorTok{$}\NormalTok{population)}

\CommentTok{# Define a variable ind to store the indexes needed to order the population values}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{order}\NormalTok{(murders}\OperatorTok{$}\NormalTok{population)}

\CommentTok{# Create a data frame my_df with the state name and its rank and ordered from least populous to most }
\NormalTok{my_df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{states =}\NormalTok{ states[ind], }\DataTypeTok{ranks =}\NormalTok{ ranks[ind])}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  The \texttt{na\_example} dataset represents a series of counts. It is
  included in the \emph{dslabs} package.
\end{enumerate}

You can quickly examine the object using

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dslabs)}
\KeywordTok{data}\NormalTok{(na_example)}
\KeywordTok{str}\NormalTok{(na_example)}
\end{Highlighting}
\end{Shaded}

However, when we compute the average we obtain an \texttt{NA}. You can
see this by typing

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(na_example)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Using new dataset }
\KeywordTok{library}\NormalTok{(dslabs)}
\KeywordTok{data}\NormalTok{(na_example)}

\CommentTok{# Checking the structure }
\KeywordTok{str}\NormalTok{(na_example)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  int [1:1000] 2 1 3 2 1 3 1 4 3 2 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Find out the mean of the entire dataset }
\KeywordTok{mean}\NormalTok{(na_example)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Use is.na to create a logical index ind that tells which entries are NA}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{is.na}\NormalTok{(na_example)}

\CommentTok{# Determine how many NA ind has using the sum function}
\KeywordTok{sum}\NormalTok{(ind)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 145
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  We previously computed the average of \texttt{na\_example} using
  \texttt{mean(na\_example)} and obtain \texttt{NA}. This is because the
  function \texttt{mean} returns \texttt{NA} if it encounters at least
  one \texttt{NA}. A common operation is therefore removing the entries
  that are NA and after that perform operations on the rest.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Note what we can do with the ! operator}
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\NormalTok{x[}\OperatorTok{!}\NormalTok{ind]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create the ind vector}
\KeywordTok{library}\NormalTok{(dslabs)}
\KeywordTok{data}\NormalTok{(na_example)}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{is.na}\NormalTok{(na_example)}

\CommentTok{# We saw that this gives an NA}
\KeywordTok{mean}\NormalTok{(na_example)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Compute the average, for entries of na_example that are not NA}
\KeywordTok{mean}\NormalTok{(na_example[}\OperatorTok{!}\NormalTok{ind])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.3
\end{verbatim}

\hypertarget{vector-arithmetic}{%
\subsection{Vector arithmetic}\label{vector-arithmetic}}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/r-basics.html\#vector-arithmetics}{here}

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  In R, arithmetic operations on vectors occur element-wise.
\end{itemize}

\emph{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# The name of the state with the maximum population is found by doing the following}
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[}\KeywordTok{which.max}\NormalTok{(murders}\OperatorTok{$}\NormalTok{population)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "California"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# how to obtain the murder rate}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total }\OperatorTok{/}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population }\OperatorTok{*}\StringTok{ }\DecValTok{100000}

\CommentTok{# ordering the states by murder rate, in decreasing order}
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[}\KeywordTok{order}\NormalTok{(murder_rate, }\DataTypeTok{decreasing=}\OtherTok{TRUE}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "District of Columbia" "Louisiana"            "Missouri"            
##  [4] "Maryland"             "South Carolina"       "Delaware"            
##  [7] "Michigan"             "Mississippi"          "Georgia"             
## [10] "Arizona"              "Pennsylvania"         "Tennessee"           
## [13] "Florida"              "California"           "New Mexico"          
## [16] "Texas"                "Arkansas"             "Virginia"            
## [19] "Nevada"               "North Carolina"       "Oklahoma"            
## [22] "Illinois"             "Alabama"              "New Jersey"          
## [25] "Connecticut"          "Ohio"                 "Alaska"              
## [28] "Kentucky"             "New York"             "Kansas"              
## [31] "Indiana"              "Massachusetts"        "Nebraska"            
## [34] "Wisconsin"            "Rhode Island"         "West Virginia"       
## [37] "Washington"           "Colorado"             "Montana"             
## [40] "Minnesota"            "South Dakota"         "Oregon"              
## [43] "Wyoming"              "Maine"                "Utah"                
## [46] "Idaho"                "Iowa"                 "North Dakota"        
## [49] "Hawaii"               "New Hampshire"        "Vermont"
\end{verbatim}

\hypertarget{assessment---vector-arithmetic}{%
\subsection{Assessment - Vector
Arithmetic}\label{assessment---vector-arithmetic}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Previously we created this data frame.
\end{enumerate}

\texttt{\{r,\ eval=FALSE,\ echo=TRUE\ temp\ \textless{}-\ c(35,\ 88,\ 42,\ 84,\ 81,\ 30)\ city\ \textless{}-\ c("Beijing",\ "Lagos",\ "Paris",\ "Rio\ de\ Janeiro",\ "San\ Juan",\ "Toronto")\ city\_temps\ \textless{}-\ data.frame(name\ =\ city,\ temperature\ =\ temp)}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Assign city names to `city` }
\NormalTok{city <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Beijing"}\NormalTok{, }\StringTok{"Lagos"}\NormalTok{, }\StringTok{"Paris"}\NormalTok{, }\StringTok{"Rio de Janeiro"}\NormalTok{, }\StringTok{"San Juan"}\NormalTok{, }\StringTok{"Toronto"}\NormalTok{)}

\CommentTok{# Store temperature values in `temp`}
\NormalTok{temp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{88}\NormalTok{, }\DecValTok{42}\NormalTok{, }\DecValTok{84}\NormalTok{, }\DecValTok{81}\NormalTok{, }\DecValTok{30}\NormalTok{)}

\CommentTok{# Convert temperature into Celsius and overwrite the original values of 'temp' with these Celsius values}
\NormalTok{temp <-}\StringTok{ }\DecValTok{5}\OperatorTok{/}\DecValTok{9} \OperatorTok{*}\StringTok{ }\NormalTok{(temp }\DecValTok{-32}\NormalTok{)}

\CommentTok{# Create a data frame `city_temps` }
\NormalTok{city_temps <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{name =}\NormalTok{ city, }\DataTypeTok{temperature =}\NormalTok{ temp)}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  We can use some of what we have learned to perform calculations that
  would otherwise be quite complicated. Let's see an example.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Define an object `x` with the numbers 1 through 100}
\NormalTok{x <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{100}\NormalTok{)}

\CommentTok{# Compute the sum }
\KeywordTok{sum}\NormalTok{((}\DecValTok{1}\OperatorTok{/}\NormalTok{x)}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.63
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Compute the per 100,000 murder rate for each state and store it in the
  object \texttt{murder\_rate}. Then compute the average murder rate for
  the US using the function \texttt{mean}. What is the average?
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the per 100,000 murder rate for each state in murder_rate}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total }\OperatorTok{/}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population }\OperatorTok{*}\StringTok{ }\DecValTok{100000}

\CommentTok{# Calculate the average murder rate in the US }
\KeywordTok{mean}\NormalTok{(murder_rate)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.78
\end{verbatim}

\hypertarget{section-2-assessment}{%
\subsection{Section 2 Assessment}\label{section-2-assessment}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Consider the vector
  \texttt{x\ \textless{}-\ c(2,\ 43,\ 27,\ 96,\ 18)}.
\end{enumerate}

Match the following outputs to the function which produces that output.
Options include \texttt{sort(x)}, \texttt{order(x)}, \texttt{rank(x)}
and none of these.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{96}\NormalTok{, }\DecValTok{18}\NormalTok{)}
\KeywordTok{sort}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2 18 27 43 96
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{order}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 5 3 2 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rank}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 4 3 5 2
\end{verbatim}

\texttt{1,\ 2,\ 3,\ 4,\ 5} none of these

\texttt{1,\ 5,\ 3,\ 2,\ 4} order(x)

\texttt{1,\ 4,\ 3,\ 5,\ 2} rank(x)

\texttt{2,\ 18,\ 27,\ 43,\ 96} sort(x)

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Continue working with the vector
  \texttt{x\ \textless{}-\ c(2,\ 43,\ 27,\ 96,\ 18)}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{43}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{96}\NormalTok{, }\DecValTok{18}\NormalTok{)}
\KeywordTok{min}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which.min}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{max}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 96
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which.max}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\texttt{min(x)} 2

\texttt{which.min(x)} 1

\texttt{max(x)} none of these

\texttt{which.max(x)} 4

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Mandi, Amy, Nicole, and Olivia all ran different distances in
  different time intervals. Their distances (in miles) and times (in
  minutes) are as follows:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Mandi"}\NormalTok{, }\StringTok{"Amy"}\NormalTok{, }\StringTok{"Nicole"}\NormalTok{, }\StringTok{"Olivia"}\NormalTok{)}
\NormalTok{distance <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{0.8}\NormalTok{, }\FloatTok{3.1}\NormalTok{, }\FloatTok{2.8}\NormalTok{, }\FloatTok{4.0}\NormalTok{)}
\NormalTok{time <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Write a line of code to convert time to hours. Remember there are 60
minutes in an hour. Then write a line of code to calculate the speed of
each runner in miles per hour. Speed is distance divided by time.

How many hours did Olivia run?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hours <-}\StringTok{ }\NormalTok{time}\OperatorTok{/}\DecValTok{60}
\NormalTok{hours[}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.833
\end{verbatim}

What was Mandi's speed in miles per hour?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{speed <-}\StringTok{ }\NormalTok{distance}\OperatorTok{/}\NormalTok{hours}
\NormalTok{speed[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4.8
\end{verbatim}

Which runner had the fastest speed?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name[}\KeywordTok{which.max}\NormalTok{(speed)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Amy"
\end{verbatim}

\hypertarget{section-3-overview}{%
\subsection{Section 3 Overview}\label{section-3-overview}}

Section 3 introduces to the R commands and techniques that help you
wrangle, analyze, and visualize data.

In Section 3.1, you will:

\begin{itemize}
\tightlist
\item
  Subset a vector based on properties of another vector.
\item
  Use multiple logical operators to index vectors.
\item
  Extract the indices of vector elements satisfying one or more logical
  conditions.
\item
  Extract the indices of vector elements matching with another vector.
\item
  Determine which elements in one vector are present in another vector.
\end{itemize}

In Section 3.2, you will:

\begin{itemize}
\tightlist
\item
  Wrangle data tables using the functions in `dplyr' package.
\item
  Modify a data table by adding or changing columns.
\item
  Subset rows in a data table.
\item
  Subset columns in a data table.
\item
  Perform a series of operations using the pipe operator.
\item
  Create data frames.
\end{itemize}

In Section 3.3, you will:

\begin{itemize}
\tightlist
\item
  Plot data in scatter plots, box plots and histograms.
\end{itemize}

\hypertarget{indexing}{%
\subsection{Indexing}\label{indexing}}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/r-basics.html\#indexing}{here}

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  We can use logicals to index vectors.
\item
  Using the function \textgreater sum()on a logical vector returns the
  number of entries that are true.
\item
  The logical operator ``\&'' makes two logicals true only when they are
  both true.
\end{itemize}

\emph{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# defining murder rate as before}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total }\OperatorTok{/}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population }\OperatorTok{*}\StringTok{ }\DecValTok{100000}
\CommentTok{# creating a logical vector that specifies if the murder rate in that state is less than or equal to 0.71}
\NormalTok{index <-}\StringTok{ }\NormalTok{murder_rate }\OperatorTok{<=}\StringTok{ }\FloatTok{0.71}
\CommentTok{# determining which states have murder rates less than or equal to 0.71}
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hawaii"        "Iowa"          "New Hampshire" "North Dakota" 
## [5] "Vermont"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# calculating how many states have a murder rate less than or equal to 0.71}
\KeywordTok{sum}\NormalTok{(index)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# creating the two logical vectors representing our conditions}
\NormalTok{west <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{region }\OperatorTok{==}\StringTok{ "West"}
\NormalTok{safe <-}\StringTok{ }\NormalTok{murder_rate }\OperatorTok{<=}\StringTok{ }\DecValTok{1}
\CommentTok{# defining an index and identifying states with both conditions true}
\NormalTok{index <-}\StringTok{ }\NormalTok{safe }\OperatorTok{&}\StringTok{ }\NormalTok{west}
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[index]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hawaii"  "Idaho"   "Oregon"  "Utah"    "Wyoming"
\end{verbatim}

\hypertarget{indexing---indexing-functions}{%
\subsection{Indexing - Indexing
Functions}\label{indexing---indexing-functions}}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/r-basics.html\#which}{here}

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  The function which() gives us the entries of a logical vector that are
  true.
\item
  The function match() looks for entries in a vector and returns the
  index needed to access them.
\item
  We use the function \%in\% if we want to know whether or not each
  element of a first vector is in a second vector.
\end{itemize}

\emph{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# to determine the murder rate in Massachusetts we may do the following}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{which}\NormalTok{(murders}\OperatorTok{$}\NormalTok{state }\OperatorTok{==}\StringTok{ "Massachusetts"}\NormalTok{)}
\NormalTok{murder_rate[ind]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# to obtain the indices and subsequent murder rates of New York, Florida, Texas, we do:}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{match}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"New York"}\NormalTok{, }\StringTok{"Florida"}\NormalTok{, }\StringTok{"Texas"}\NormalTok{), murders}\OperatorTok{$}\NormalTok{state)}
\NormalTok{ind}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 33 10 44
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{murder_rate[ind]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.67 3.40 3.20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# to see if Boston, Dakota, and Washington are states}
\KeywordTok{c}\NormalTok{(}\StringTok{"Boston"}\NormalTok{, }\StringTok{"Dakota"}\NormalTok{, }\StringTok{"Washington"}\NormalTok{) }\OperatorTok{%in%}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{state}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE  TRUE
\end{verbatim}

\hypertarget{assessment---indexing}{%
\subsection{Assessment - Indexing}\label{assessment---indexing}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Here we will be using logical operators to create a logical vector.
  Compute the per 100,000 murder rate for each state and store it in an
  object called \texttt{murder\_rate}. Then use logical operators to
  create a logical vector named \texttt{low} that tells us which entries
  of \texttt{murder\_rate} are lower than 1.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the murder rate per 100,000 for each state, in `murder_rate`}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total }\OperatorTok{/}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population }\OperatorTok{*}\StringTok{ }\DecValTok{100000}

\CommentTok{# Store the `murder_rate < 1` in `low` }
\NormalTok{low <-}\StringTok{ }\NormalTok{murder_rate }\OperatorTok{<}\StringTok{ }\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  The function `\texttt{which()} helps us know directly, which values
  are low or high, etc. Let's use it in this question.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the murder rate per 100,000 for each state, in murder_rate}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total}\OperatorTok{/}\NormalTok{murders}\OperatorTok{$}\NormalTok{population}\OperatorTok{*}\DecValTok{100000}

\CommentTok{# Store the murder_rate < 1 in low }
\NormalTok{low <-}\StringTok{ }\NormalTok{murder_rate }\OperatorTok{<}\StringTok{ }\DecValTok{1}

\CommentTok{# Get the indices of entries that are below 1}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{which}\NormalTok{(low)}
\NormalTok{ind}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 12 13 16 20 24 30 35 38 42 45 46 51
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Note that if we want to know which entries of a vector are lower than
  a particular value we can use code like this.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{small <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{population }\OperatorTok{<}\StringTok{ }\DecValTok{1000000}
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[small]}
\end{Highlighting}
\end{Shaded}

The code above shows us the states with populations smaller than one
million.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the murder rate per 100,000 for each state, in murder_rate}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total}\OperatorTok{/}\NormalTok{murders}\OperatorTok{$}\NormalTok{population}\OperatorTok{*}\DecValTok{100000}

\CommentTok{# Store the murder_rate < 1 in low }
\NormalTok{low <-}\StringTok{ }\NormalTok{murder_rate }\OperatorTok{<}\StringTok{ }\DecValTok{1}

\CommentTok{# Names of states with murder rates lower than 1}
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[low]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Hawaii"        "Idaho"         "Iowa"          "Maine"        
##  [5] "Minnesota"     "New Hampshire" "North Dakota"  "Oregon"       
##  [9] "South Dakota"  "Utah"          "Vermont"       "Wyoming"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Now we will extend the code from the previous exercises to report the
  states in the Northeast with a murder rate lower than 1.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the murder rate per 100,000 for each state, in `murder_rate`}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total}\OperatorTok{/}\NormalTok{murders}\OperatorTok{$}\NormalTok{population}\OperatorTok{*}\DecValTok{100000}

\CommentTok{# Store the `murder_rate < 1` in `low` }
\NormalTok{low <-}\StringTok{ }\NormalTok{murder_rate }\OperatorTok{<}\StringTok{ }\DecValTok{1}

\CommentTok{# Create a vector ind for states in the Northeast and with murder rates lower than 1. }
\NormalTok{northeast <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{region }\OperatorTok{==}\StringTok{ "Northeast"}
\NormalTok{ind <-}\StringTok{ }\NormalTok{low }\OperatorTok{&}\StringTok{ }\NormalTok{northeast}

\CommentTok{# Names of states in `ind` }
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[ind]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Maine"         "New Hampshire" "Vermont"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  In a previous exercise we computed the murder rate for each state and
  the average of these numbers. How many states are below the average?
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the murder rate per 100,000 for each state, in murder_rate}
\NormalTok{murder_rate <-}\StringTok{ }\NormalTok{murders}\OperatorTok{$}\NormalTok{total}\OperatorTok{/}\NormalTok{murders}\OperatorTok{$}\NormalTok{population}\OperatorTok{*}\DecValTok{100000}


\CommentTok{# Compute the average murder rate using `mean` and store it in object named `avg`}
\NormalTok{avg <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(murder_rate)}

\CommentTok{# How many states have murder rates below avg ? Check using sum }
\NormalTok{ind <-}\StringTok{ }\NormalTok{murder_rate }\OperatorTok{<}\StringTok{ }\NormalTok{avg}
\KeywordTok{sum}\NormalTok{(ind)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 27
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  In this exercise we use the \texttt{match} function to identify the
  states with abbreviations AK, MI, and IA.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the 3 abbreviations in a vector called `abbs` (remember that they are character vectors and need quotes)}
\NormalTok{abbs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"AK"}\NormalTok{, }\StringTok{"MI"}\NormalTok{, }\StringTok{"IA"}\NormalTok{)}

\CommentTok{# Match the abbs to the murders$abb and store in ind}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{match}\NormalTok{(abbs, murders}\OperatorTok{$}\NormalTok{abb)}

\CommentTok{# Print state names from ind}
\NormalTok{murders}\OperatorTok{$}\NormalTok{state[ind]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Alaska"   "Michigan" "Iowa"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  If rather than an index we want a logical that tells us whether or not
  each element of a first vector is in a second, we can use the function
  \texttt{\%in\%}.
\end{enumerate}

For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{x}\OperatorTok{%in%}\NormalTok{y}
\end{Highlighting}
\end{Shaded}

Gives us two \texttt{TRUE} followed by a \texttt{FALSE} because 2 and 3
are in \texttt{y} but 5 is not.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the 5 abbreviations in `abbs`. (remember that they are character vectors)}
\NormalTok{abbs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"MA"}\NormalTok{, }\StringTok{"ME"}\NormalTok{, }\StringTok{"MI"}\NormalTok{, }\StringTok{"MO"}\NormalTok{, }\StringTok{"MU"}\NormalTok{)}

\CommentTok{# Use the %in% command to check if the entries of abbs are abbreviations in the the murders data frame}
\NormalTok{abbs}\OperatorTok{%in%}\NormalTok{murders}\OperatorTok{$}\NormalTok{abb}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE  TRUE  TRUE  TRUE FALSE
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  In a previous exercise we computed the index
  \texttt{abbs\%in\%murders\$abb}. Based on that, and using the
  \texttt{which} function and the \texttt{!} operator, get the index of
  the entries of \texttt{abbs} that are \textbf{not} abbreviations.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Store the 5 abbreviations in abbs. (remember that they are character vectors)}
\NormalTok{abbs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"MA"}\NormalTok{, }\StringTok{"ME"}\NormalTok{, }\StringTok{"MI"}\NormalTok{, }\StringTok{"MO"}\NormalTok{, }\StringTok{"MU"}\NormalTok{) }

\CommentTok{# Use the `which` command and `!` operator to find out which index abbreviations are not actually part of the dataset and store in `ind`}
\NormalTok{ind <-}\StringTok{ }\KeywordTok{which}\NormalTok{(}\OperatorTok{!}\NormalTok{abbs}\OperatorTok{%in%}\NormalTok{murders}\OperatorTok{$}\NormalTok{abb)}

\CommentTok{# Names of abbreviations in `ind`}
\NormalTok{abbs[ind]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "MU"
\end{verbatim}

\hypertarget{basic-data-wrangling}{%
\subsection{Basic Data Wrangling}\label{basic-data-wrangling}}

The textbook for this section is available
\href{https://rafalab.github.io/dsbook/tidyverse.html\#manipulating-data-frames}{here}
and
\href{https://rafalab.github.io/dsbook/tidyverse.html\#the-pipe}{here}

In the textbook, the dplyr package is introduced in the context of the
tidyverse, a collection of R packages

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  To change a data table by adding a new column, or changing an existing
  one, we use the \texttt{mutate} function.
\item
  To filter the data by subsetting rows, we use the function
  \texttt{filter}.
\item
  To subset the data by selecting specific columns, we use the
  \texttt{select} function.
\item
  We can perform a series of operations by sending the results of one
  function to another function using what is called the pipe operator,
  \texttt{\%\textgreater{}\%}.
\end{itemize}

\emph{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# installing and loading the dplyr package}
\ControlFlowTok{if}\NormalTok{(}\OperatorTok{!}\KeywordTok{require}\NormalTok{(dplyr)) }\KeywordTok{install.packages}\NormalTok{(}\StringTok{"dplyr"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Loading required package: dplyr
\end{verbatim}

\begin{verbatim}
## 
## Attaching package: 'dplyr'
\end{verbatim}

\begin{verbatim}
## The following objects are masked from 'package:stats':
## 
##     filter, lag
\end{verbatim}

\begin{verbatim}
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}

\CommentTok{# adding a column with mutate}
\KeywordTok{library}\NormalTok{(dslabs)}
\KeywordTok{data}\NormalTok{(}\StringTok{"murders"}\NormalTok{)}
\NormalTok{murders <-}\StringTok{ }\KeywordTok{mutate}\NormalTok{(murders, }\DataTypeTok{rate =}\NormalTok{ total }\OperatorTok{/}\StringTok{ }\NormalTok{population }\OperatorTok{*}\StringTok{ }\DecValTok{100000}\NormalTok{)}

\CommentTok{# subsetting with filter}
\KeywordTok{filter}\NormalTok{(murders, rate }\OperatorTok{<=}\StringTok{ }\FloatTok{0.71}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           state abb        region population total  rate
## 1        Hawaii  HI          West    1360301     7 0.515
## 2          Iowa  IA North Central    3046355    21 0.689
## 3 New Hampshire  NH     Northeast    1316470     5 0.380
## 4  North Dakota  ND North Central     672591     4 0.595
## 5       Vermont  VT     Northeast     625741     2 0.320
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# selecting columns with select}
\NormalTok{new_table <-}\StringTok{ }\KeywordTok{select}\NormalTok{(murders, state, region, rate)}

\CommentTok{# using the pipe}
\NormalTok{murders }\OperatorTok{%>%}\StringTok{ }\KeywordTok{select}\NormalTok{(state, region, rate) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{filter}\NormalTok{(rate }\OperatorTok{<=}\StringTok{ }\FloatTok{0.71}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           state        region  rate
## 1        Hawaii          West 0.515
## 2          Iowa North Central 0.689
## 3 New Hampshire     Northeast 0.380
## 4  North Dakota North Central 0.595
## 5       Vermont     Northeast 0.320
\end{verbatim}

\hypertarget{basic-data-wrangling---creating-data-frames}{%
\subsection{Basic Data Wrangling - Creating Data
Frames}\label{basic-data-wrangling---creating-data-frames}}

\textbf{Key Points}

\begin{itemize}
\tightlist
\item
  We can use the \texttt{data.frame()} function to create data frames.
\item
  By default, the \texttt{data.frame()} function turns characters into
  factors. To avoid this, we utilize the \texttt{stringsAsFactors}
  argument and set it equal to false.
\end{itemize}

\emph{Code}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# creating a data frame with stringAsFactors = FALSE}
\NormalTok{grades <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{names =} \KeywordTok{c}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\StringTok{"Juan"}\NormalTok{, }\StringTok{"Jean"}\NormalTok{, }\StringTok{"Yao"}\NormalTok{), }
                     \DataTypeTok{exam_1 =} \KeywordTok{c}\NormalTok{(}\DecValTok{95}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{90}\NormalTok{, }\DecValTok{85}\NormalTok{), }
                     \DataTypeTok{exam_2 =} \KeywordTok{c}\NormalTok{(}\DecValTok{90}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{85}\NormalTok{, }\DecValTok{90}\NormalTok{),}
                     \DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{assessment-7}{%
\subsection{Assessment 7}\label{assessment-7}}

Load the dplyr package and the murders dataset.

\begin{verbatim}
library(dplyr)
library(dslabs)
data(murders)
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  You can add columns using the dplyr function mutate. This function is
  aware of the column names and inside the function you can call them
  unquoted. Like this:
\end{enumerate}

\begin{verbatim}
murders <- mutate(murders, population_in_millions = population / 10^6)
\end{verbatim}

Note that we can write population rather than
murders\(population. The function mutate knows we are grabing columns from murders.\
Use the function mutate to add a murders column named rate with the per 100,000 murder rate. Make sure you redefine murders as done in the example code above. Remember the murder rate is defined the total divided by the population size times 100,000. ``` # Redefine murders so that it includes column named rate with the per 100,000 murder rates murders <- mutate(murders, rate=total/murders\)population*100000)

\begin{verbatim}
2. mutate

Note that if rank(x) gives you the ranks of x from lowest to highest, rank(-x) gives you the ranks from highest to lowest. Use the function mutate to add a column rank containing the rank, from highest to lowest murder rate. Make sure you redeinfe murders.
\end{verbatim}

\hypertarget{note-that-if-you-want-ranks-from-highest-to-lowest-you-can-take-the-negative-and-then-compute-the-ranks}{%
\section{Note that if you want ranks from highest to lowest you can take
the negative and then compute the
ranks}\label{note-that-if-you-want-ranks-from-highest-to-lowest-you-can-take-the-negative-and-then-compute-the-ranks}}

x \textless- c(88, 100, 83, 92, 94) rank(-x)

\begin{verbatim}
\end{verbatim}

\hypertarget{section}{%
\subsection{{[}1{]} 4 1 5 3 2}\label{section}}

\begin{verbatim}
\end{verbatim}

\hypertarget{defining-rate}{%
\section{Defining rate}\label{defining-rate}}

rate \textless- murders\(total/ murders\)population * 100000

\hypertarget{redefine-murders-to-include-a-column-named-rank}{%
\section{Redefine murders to include a column named
rank}\label{redefine-murders-to-include-a-column-named-rank}}

\hypertarget{with-the-ranks-of-rate-from-highest-to-lowest}{%
\section{with the ranks of rate from highest to
lowest}\label{with-the-ranks-of-rate-from-highest-to-lowest}}

murders \textless- mutate(murders,rank=rank(-rate))

\begin{verbatim}
3. select

With dplyr we can use select to show only certain columns. For example with this code we would only show the states and population sizes:
\end{verbatim}

select(murders, state, population)

\begin{verbatim}
Use select to show the state names and abbreviations in murders. Just show it, do not define a new object.
\end{verbatim}

\hypertarget{load-dplyr}{%
\section{Load dplyr}\label{load-dplyr}}

library(dplyr)

\hypertarget{use-select-to-only-show-state-names-and-abbreviations-from-murders}{%
\section{Use select to only show state names and abbreviations from
murders}\label{use-select-to-only-show-state-names-and-abbreviations-from-murders}}

select(murders,state,abb)

state abb Alabama AL Alaska AK Arizona AZ Arkansas AR California CA
Colorado CO Connecticut CT Delaware DE District of Columbia DC Florida
FL 1-10 of 51 rows

\begin{verbatim}
4. filter
    
The dplyr function filter is used to choose specific rows of the data frame to keep. Unlke select which is for columns, filter is for rows. For example you can show just New York row like this:
\end{verbatim}

filter(murders, state == ``New York'')

\begin{verbatim}
You can use other logical vector to filter rows.
Use filter to show the top 5 states with the highest murder rates. After we add murder rate and rank, do not change the murders dataset, just show the result. Note that you can filter based on the rank column.
\end{verbatim}

\hypertarget{add-the-necessary-columns}{%
\section{Add the necessary columns}\label{add-the-necessary-columns}}

murders \textless- mutate(murders, rate = total/population * 100000,
rank = rank(-rate))

\hypertarget{filter-to-show-the-top-5-states-with-the-highest-murder-rates}{%
\section{Filter to show the top 5 states with the highest murder
rates}\label{filter-to-show-the-top-5-states-with-the-highest-murder-rates}}

filter(murders,rate,rank\textless=5)

state abb region population total rate rank District of Columbia DC
South 601723 99 16.452753 1 Louisiana LA South 4533372 351 7.742581 2
Maryland MD South 5773552 293 5.074866 4 Missouri MO North Central
5988927 321 5.359892 3 South Carolina SC South 4625364 207 4.475323 5 5
rows

\begin{verbatim}
5. filter with !=

We can remove rows using the != operator. For example to remove Florida we would do this:
\end{verbatim}

no\_florida \textless- filter(murders, state != ``Florida'')

\begin{verbatim}
Create a new data frame called no_south that removes states from the South region. How many states are in this category? You can use the function nrow for this.
\end{verbatim}

\hypertarget{use-filter-to-create-a-new-data-frame-no_south}{%
\section{Use filter to create a new data frame
no\_south}\label{use-filter-to-create-a-new-data-frame-no_south}}

no\_south \textless- filter(murders, region != `South')

\hypertarget{use-nrow-to-calculate-the-number-of-rows}{%
\section{Use nrow() to calculate the number of
rows}\label{use-nrow-to-calculate-the-number-of-rows}}

nrow(no\_south)

\begin{verbatim}
\end{verbatim}

\hypertarget{section-1}{%
\subsection{{[}1{]} 34}\label{section-1}}

\begin{verbatim}
6. filter with %in%
    
We can also use the %in% to filter with dplyr. For example you can see the data from New York and Texas like this:
\end{verbatim}

filter(murders, state \%in\% c(``New York'', ``Texas''))

\begin{verbatim}
Create a new data frame called murders_nw with only the states from the Northeast and the West. How many states are in this category?
\end{verbatim}

\hypertarget{create-a-new-data-frame-called-murders_nw-with-only-the-states-from-the-northeast-and-the-west}{%
\section{Create a new data frame called murders\_nw with only the states
from the northeast and the
west}\label{create-a-new-data-frame-called-murders_nw-with-only-the-states-from-the-northeast-and-the-west}}

murders\_nw \textless- filter(murders, region \%in\%
c(`Northeast',`West'))

\hypertarget{number-of-states-rows-in-this-category}{%
\section{Number of states (rows) in this
category}\label{number-of-states-rows-in-this-category}}

nrow(murders\_nw)

\begin{verbatim}
\end{verbatim}

\hypertarget{section-2}{%
\subsection{{[}1{]} 22}\label{section-2}}

\begin{verbatim}
7. filtering by two conditions

Suppose you want to live in the Northeast or West and want the murder rate to be less than 1. We want to see the data for the states satisfying these options. Note that you can use logical operators with filter:
\end{verbatim}

filter(murders, population \textless{} 5000000 \& region ==
``Northeast'')

\begin{verbatim}
Add a murder rate column and a rank column as done before. Create a table, call it my_states, that satisfies both the conditions: it is in the Northeast or West and the murder rate is less than 1. Use select to show only the state name, the rate and the rank.
\end{verbatim}

\hypertarget{add-the-rate-column}{%
\section{add the rate column}\label{add-the-rate-column}}

murders \textless- mutate(murders, rate = total / population * 100000,
rank = rank(-rate))

\hypertarget{create-a-table-call-it-my_states-that-satisfies-both-the-conditions}{%
\section{Create a table, call it my\_states, that satisfies both the
conditions}\label{create-a-table-call-it-my_states-that-satisfies-both-the-conditions}}

my\_states \textless- filter(murders, region \%in\%
c(`Northeast',`West') \& rate \textless{} 1)

\hypertarget{use-select-to-show-only-the-state-name-the-murder-rate-and-the-rank}{%
\section{Use select to show only the state name, the murder rate and the
rank}\label{use-select-to-show-only-the-state-name-the-murder-rate-and-the-rank}}

select(my\_states,state,rate,rank)

state rate rank Hawaii 0.5145920 49 Idaho 0.7655102 46 Maine 0.8280881
44 New Hampshire 0.3798036 50 Oregon 0.9396843 42 Utah 0.7959810 45
Vermont 0.3196211 51 Wyoming 0.8871131 43 8 rows

\begin{verbatim}
8. Using the pipe %>%

The pipe %>% can be used to perform operations sequentially without having to define intermediate objects. After redefining murder to include rate and rank.
\end{verbatim}

library(dplyr) murders \textless- mutate(murders, rate = total /
population * 100000, rank = (-rate))

\begin{verbatim}
in the solution to the previous exercise we did the following:

Created a table
\end{verbatim}

my\_states \textless- filter(murders, region \%in\% c(``Northeast'',
``West'') \& rate \textless{} 1)

\begin{verbatim}
Used select to show only the state name, the murder rate and the rank
\end{verbatim}

select(my\_states, state, rate, rank)

\begin{verbatim}
The pipe %>% permits us to perform both operation sequentially and without having to define an intermediate variable my_states

For example we could have mutated and selected in the same line like this:
\end{verbatim}

mutate(murders, rate = total / population * 100000, rank = (-rate))
\%\textgreater\% select(state, rate, rank)

\begin{verbatim}
Note that select no longer has a data frame as the first argument. The first argument is assumed to be the result of the operation conducted right before the %>%

Repeat the previous exercise, but now instead of creating a new object, show the result and only include the state, rate, and rank columns. Use a pipe %>% to do this in just one line.
\end{verbatim}

\hypertarget{load-library}{%
\section{Load library}\label{load-library}}

library(dplyr)

\begin{verbatim}
\end{verbatim}

\hypertarget{define-the-rate-column}{%
\subsection{Define the rate column}\label{define-the-rate-column}}

murders \textless- mutate(murders, rate = total / population * 100000,
rank = rank(-rate))

\begin{verbatim}
\end{verbatim}

\hypertarget{show-the-result-and-only-include-the-state-rate-and-rank-columns-all-in-one-line}{%
\section{show the result and only include the state, rate, and rank
columns, all in one
line}\label{show-the-result-and-only-include-the-state-rate-and-rank-columns-all-in-one-line}}

filter(murders, region \%in\% c(``Northeast'', ``West'') \& rate
\textless{} 1 ) \%\textgreater\% select(state, rate, rank)

state rate rank Hawaii 0.5145920 49 Idaho 0.7655102 46 Maine 0.8280881
44 New Hampshire 0.3798036 50 Oregon 0.9396843 42 Utah 0.7959810 45
Vermont 0.3196211 51 Wyoming 0.8871131 43 8 rows

\begin{verbatim}
9. mutate, filter and select

Now we will make murders the original table one gets when loading using data(murders). Use just one line to create a new data frame, called, my_states that has murder rate and rank column, consider only states in the Northeast or West, which have a murder rate lower than 1 and contain only the state, rate, and rank columns. The line should have four components separated by three %>%.
- The original dataset murders
- A call to mutate to add the murder rate and the rank.
- A call to filter to keep only the states from the Northeast or West and that have a murder rate below 1
- A call to select that keeps only the columns with the stata name, the murder rate and the rank.

The line should look something like this my_states <- murders %>% mutate something %>% filter something %>% select something. Please, make sure the columns in the final data frame must be in the order: state, rate, rank.
\end{verbatim}

\hypertarget{loading-the-libraries}{%
\section{Loading the libraries}\label{loading-the-libraries}}

library(dplyr) data(murders)

\hypertarget{create-new-data-frame-called-my_states-with-specifications-in-the-instructions}{%
\section{Create new data frame called my\_states (with specifications in
the
instructions)}\label{create-new-data-frame-called-my_states-with-specifications-in-the-instructions}}

my\_states \textless- murders \%\textgreater\%
mutate(rate=total/murders\$population*100000, rank=rank(-rate))
\%\textgreater\% filter(region \%in\% c(`Northeast',`West') \& rate
\textless1) \%\textgreater\% select(state,rate,rank)

\begin{verbatim}
## Assessment 8

1. We made a plot of total murders versus population and noted a strong relationship. Not surprisingly, states with larger populations had more murders.
\end{verbatim}

library(dslabs) data(murders) population\_in\_millions \textless-
murders\(population/10^6 total_gun_murders <− murders\)total
plot(population\_in\_millions, total\_gun\_murders)

\begin{verbatim}
Keep in mind that many states have populations below 5 million and are bunched up. We may gain further insights from making this plot in the log scale. Transform the variables using the log10 transformation and then plot them.
\end{verbatim}

\hypertarget{load-the-datasets-and-define-some-variables}{%
\section{Load the datasets and define some
variables}\label{load-the-datasets-and-define-some-variables}}

library(dslabs) data(murders)

population\_in\_millions \textless-
murders\(population/10^6 total_gun_murders <- murders\)total

plot(population\_in\_millions, total\_gun\_murders)

\begin{verbatim}
![index](https://user-images.githubusercontent.com/17474099/75668573-cdb1c800-5c79-11ea-98c3-222b70b1eb88.png)
\end{verbatim}

\hypertarget{transform-population-using-the-log10-transformation-and-save-to-object-log10_population}{%
\section{Transform population using the log10 transformation and save to
object
log10\_population}\label{transform-population-using-the-log10-transformation-and-save-to-object-log10_population}}

log10\_population \textless-log10(murders\$population)

\hypertarget{transform-total-gun-murders-using-log10-transformation-and-save-to-object-log10_total_gun_murders}{%
\section{Transform total gun murders using log10 transformation and save
to object
log10\_total\_gun\_murders}\label{transform-total-gun-murders-using-log10-transformation-and-save-to-object-log10_total_gun_murders}}

log10\_total\_gun\_murders \textless- log10(total\_gun\_murders)

\hypertarget{create-a-scatterplot-with-the-log-scale-transformed-population-and-murders}{%
\section{Create a scatterplot with the log scale transformed population
and
murders}\label{create-a-scatterplot-with-the-log-scale-transformed-population-and-murders}}

plot(log10\_population,log10\_total\_gun\_murders)

\begin{verbatim}

![index](https://user-images.githubusercontent.com/17474099/75766283-32842580-5d41-11ea-9099-f43738a46b86.png)

2. Create a histogram of the state populations.
\end{verbatim}

\hypertarget{store-the-population-in-millions-and-save-to-population_in_millions}{%
\section{Store the population in millions and save to
population\_in\_millions}\label{store-the-population-in-millions-and-save-to-population_in_millions}}

population\_in\_millions \textless- murders\$population/10\^{}6

\hypertarget{create-a-histogram-of-this-variable}{%
\section{Create a histogram of this
variable}\label{create-a-histogram-of-this-variable}}

hist(population\_in\_millions)

\begin{verbatim}
![index](https://user-images.githubusercontent.com/17474099/75668993-7bbd7200-5c7a-11ea-98d7-bc5e28e69d07.png)

3. Generate boxplots of the state populations by region.
\end{verbatim}

\hypertarget{create-a-boxplot-of-state-populations-by-region-for-the-murders-dataset}{%
\section{Create a boxplot of state populations by region for the murders
dataset}\label{create-a-boxplot-of-state-populations-by-region-for-the-murders-dataset}}

boxplot(population\textasciitilde region, data=murders)

\begin{verbatim}
![index](https://user-images.githubusercontent.com/17474099/75669696-bc69bb00-5c7b-11ea-9cd1-bc5218b21b40.png)
## Section 4 Overview

Section 4 introduces you to general programming features like ‘if-else’, and ‘for loop’ commands so that you can write your own functions to perform various operations on datasets.

In Section 4.1, you will:
- Understand some of the programming capabilities of R.

In Section 4.2, you will:
- Use basic conditional expressions to perform different operations.
- Check if any or all elements of a logical vector are TRUE.

In Section 4.3, you will:
- Define and call functions to perform various operations.
- Pass arguments to functions, and return variables/objects from functions.

In Section 4.4, you will:
- Use ‘for’ loop to perform repeated operations.
- Articulate in-built functions of R that you could try for yourself.

The textbook for this section is available [here](https://rafalab.github.io/dsbook/programming-basics.html)

## Assessment 9

1. What will this conditional expression return?
\end{verbatim}

x \textless- c(1,2,-3,4)

if(all(x\textgreater0))\{ print(``All Postives'') \} else\{ print(``Not
all positives'') \}

\begin{verbatim}
- [ ] A. All Positives
- [X] B. Not All Positives
- [ ] C. N/A
- [ ] D. None of the above

2. Which of the following expressions is always FALSE when at least one entry of a logical vector x is TRUE?

- [ ] A. all(x)
- [ ] B. any(x)
- [ ] C. any(!x)
- [X] D. all(!x)

3. The function nchar tells you how many characters long a character vector is.

Write a line of code that assigns to the object new_names the state abbreviation when the state name is longer than 8 characters.
\end{verbatim}

\hypertarget{assign-the-state-abbreviation-when-the-state-name-is-longer-than-8-characters}{%
\section{Assign the state abbreviation when the state name is longer
than 8
characters}\label{assign-the-state-abbreviation-when-the-state-name-is-longer-than-8-characters}}

new\_names \textless- ifelse(nchar(murders\(state)>8, murders\)abb,
murders\$state)

\begin{verbatim}
4. Create a function sum_n that for any given value, say n, computes the sum of the integers from 1 to n (inclusive). Use the function to determine the sum of integers from 1 to 5,000.
\end{verbatim}

\hypertarget{create-function-called-sum_n}{%
\section{\texorpdfstring{Create function called
\texttt{sum\_n}}{Create function called sum\_n}}\label{create-function-called-sum_n}}

sum\_n \textless- function(n)\{ sum(1:n) \} \# Use the function to
determine the sum of integers from 1 to 5000 sum\_n(5000)

\begin{verbatim}
\end{verbatim}

\hypertarget{section-3}{%
\subsection{{[}1{]} 12502500}\label{section-3}}

\begin{verbatim}
5. Create a function altman_plot that takes two arguments, x and y, and plots the difference against the sum.
\end{verbatim}

\hypertarget{create-altman_plot}{%
\section{\texorpdfstring{Create
\texttt{altman\_plot}}{Create altman\_plot}}\label{create-altman_plot}}

altman\_plot \textless- function(x,y) \{ plot(x+y,y-x) \}

\begin{verbatim}
6. After running the code below, what is the value of x?
\end{verbatim}

x \textless- 3 my\_func \textless- function(y)\{ x \textless- 5 y+5 \}

\begin{verbatim}
\end{verbatim}

\hypertarget{run-this-code}{%
\section{Run this code}\label{run-this-code}}

x \textless- 3 my\_func \textless- function(y)\{ x \textless- 5 y+5 \}

\hypertarget{print-value-of-x}{%
\section{Print value of x}\label{print-value-of-x}}

print(x)

\begin{verbatim}
\end{verbatim}

\hypertarget{section-4}{%
\subsection{{[}1{]} 3}\label{section-4}}

\begin{verbatim}
7. Write a function compute_s_n that for any given n computes the sum S_n = 1^2 + 2^2 + 3^2 + . n^2. Report the value of the sum when n = 10.
\end{verbatim}

\hypertarget{here-is-an-example-of-function-that-adds-numbers-from-1-to-n}{%
\section{Here is an example of function that adds numbers from 1 to
n}\label{here-is-an-example-of-function-that-adds-numbers-from-1-to-n}}

example\_func \textless- function(n)\{ x \textless- 1:n sum(x) \}

\hypertarget{here-is-the-sum-of-the-first-100-numbers}{%
\section{Here is the sum of the first 100
numbers}\label{here-is-the-sum-of-the-first-100-numbers}}

example\_func(100)

\begin{verbatim}
\end{verbatim}

\hypertarget{section-5}{%
\subsection{{[}1{]} 5050}\label{section-5}}

\begin{verbatim}
\end{verbatim}

\hypertarget{write-a-function-compute_s_n-that-with-argument-n-and-returns-of-1-22-n2}{%
\section{Write a function compute\_s\_n that with argument n and returns
of 1 + 2\^{}2 + \ldots+
n\^{}2}\label{write-a-function-compute_s_n-that-with-argument-n-and-returns-of-1-22-n2}}

compute\_s\_n \textless- function(n)\{ x \textless- 1:n sum(x\^{}2) \}
\# Report the value of the sum when n=10 compute\_s\_n(10)

\begin{verbatim}
\end{verbatim}

\hypertarget{section-6}{%
\subsection{{[}1{]} 385}\label{section-6}}

\begin{verbatim}
8. Define an empty numerical vector s_n of size 25 using s_n <- vector(“numeric”, 25) and store in the results of S_1, S_2, . S_25 using a for-loop.
\end{verbatim}

\hypertarget{define-a-function-and-store-it-in-compute_s_n}{%
\section{\texorpdfstring{Define a function and store it in
\texttt{compute\_s\_n}}{Define a function and store it in compute\_s\_n}}\label{define-a-function-and-store-it-in-compute_s_n}}

compute\_s\_n \textless- function(n)\{ x \textless- 1:n sum(x\^{}2) \}

\hypertarget{create-a-vector-for-storing-results}{%
\section{Create a vector for storing
results}\label{create-a-vector-for-storing-results}}

s\_n \textless- vector(``numeric'', 25)

\hypertarget{write-a-for-loop-to-store-the-results-in-s_n}{%
\section{write a for-loop to store the results in
s\_n}\label{write-a-for-loop-to-store-the-results-in-s_n}}

for(i in 1:25)\{ s\_n{[}i{]} \textless- compute\_s\_n(i) \}

\begin{verbatim}
9. If we do the math, we can show that S_n=12+22+32+???+n2=n(n+1)(2n+1)/6. We have already computed the values of Sn from 1 to 25 using a for loop. If the formula is correct then a plot of Sn versus n should look cubic.
\end{verbatim}

\hypertarget{define-the-function}{%
\section{Define the function}\label{define-the-function}}

compute\_s\_n \textless- function(n)\{ x \textless- 1:n sum(x\^{}2) \}

\hypertarget{define-the-vector-of-n}{%
\section{Define the vector of n}\label{define-the-vector-of-n}}

n \textless- 1:25

\hypertarget{define-the-vector-to-store-data}{%
\section{Define the vector to store
data}\label{define-the-vector-to-store-data}}

s\_n \textless- vector(``numeric'', 25) for(i in n)\{ s\_n{[}i{]}
\textless- compute\_s\_n(i) \}

\hypertarget{create-the-plot}{%
\section{Create the plot}\label{create-the-plot}}

plot(n,s\_n)

\begin{verbatim}
![index](https://user-images.githubusercontent.com/17474099/75670998-24210580-5c7e-11ea-95fe-e6f8857049f4.png)

10. Confirm that s_n and n(n+1)(2n+1)/6 are the same using the identical command.
\end{verbatim}

\hypertarget{define-the-function-1}{%
\section{Define the function}\label{define-the-function-1}}

compute\_s\_n \textless- function(n)\{ x \textless- 1:n sum(x\^{}2) \}

\hypertarget{define-the-vector-of-n-1}{%
\section{Define the vector of n}\label{define-the-vector-of-n-1}}

n \textless- 1:25

\hypertarget{define-the-vector-to-store-data-1}{%
\section{Define the vector to store
data}\label{define-the-vector-to-store-data-1}}

s\_n \textless- vector(``numeric'', 25) for(i in n)\{ s\_n{[}i{]}
\textless- compute\_s\_n(i) \}

\hypertarget{check-that-s_n-is-identical-to-the-formula-given-in-the-instructions.}{%
\section{Check that s\_n is identical to the formula given in the
instructions.}\label{check-that-s_n-is-identical-to-the-formula-given-in-the-instructions.}}

identical(s\_n,n\emph{(n+1)}(2*n+1)/6)

\begin{verbatim}
\end{verbatim}

\hypertarget{true}{%
\subsection{{[}1{]} TRUE}\label{true}}

```

\end{document}
